###  1. 前言

​			系统间通信可以分为直接与间接通信，直接通信大家在开发中接触很多，一般使用基于请求应答模型RPC技术，用于点对点，强事务要求和延迟敏感的通信场景。而间接通信主要使用消息中间件的方式实现，消息中间件本质是增加了一个中转中间层，实现消息的临时存储和路由转发。从而可以用在很多有意思的业务场景，如系统解藕, 流量削峰，异步通信, 日志收集等。消息中间件的选择可谓琳琅满目，有许多开源的和商业的实现，在特定的业务场景，你甚至可以借助Mysql或Redis轻松实现一个自已的消息队列。本文主要介绍开源的RabbitMq, RocketMq和Kafka产品特性，实现原理和技术选型。

### 2.  概述

消息中间件的基本模型如下

​             ![image-20201126230001320](D:\person\knowledge\middleware\middleware_base.png)

Producer: 负责产生和发送消息到消息处理中心 

Broker: 消息处理中心，负责消息的接收，存储，转发等

Consumer:  从消息处理中心获取消息进行处理

一条消息从发送到消费的过程，中间要经历不少节点，下面具体分析一下各个节点有关的技术。

#### 2.1 消息发送Producer到Broker

消息发送基于不同应用场景可以选择不同的发送方式, 包括同步，异步，批量或Fire and Forget等。

有时候还需要考虑事务消息, 另外消息本身有优先级，序列化与反序列化等。 

#### 2.2 消息接收Broker

Broker端考虑消息接收后，消息可以存储是在内存中或刷盘存储,

刷盘可以考虑同步或异步， 另外为了提搞消费查询效率，会同步生成索引文件。

 Broker端同时要存储消费的或集群元数据信息

#### 2.3 消息消费Broker到Consumer

消费一般要支持点对点和发布订阅模型，其它的一些特殊还包括广播，Topic过滤等。       

消息消费方式的选择可根据应用场景选择push或pull。

消费完成需要考虑消息确认， 在一些特殊场合要支持消息回溯或消息均衡等.

以上这些技术有些定义公开的协议并标准化，如AMQP, MQTT, XMPP等，更多消息队列的使用了私有协议。

不同的消息队列产品在一些点有不同的设计取舍考虑和创新，下面我们具体看RabbitMq, RocketMq和Kafka的各自特点。

### 3.  主流消息中间件介绍

#### 3.1 RabbitMq

RabbitMq是现有中间件中支持消息模型最丰富的消息队列, 是基于AMQP高级队列消息协议的开源实现。AMQP是一个二进制的应用层协议，它定义了客户端与Broker所有的交互细节，主要包括一个通用的队列模型结构和各部分交互的命令架构和具体实现的通讯协议帧,下面分别介绍。

#### 3.1.1 通用模型

![img](D:\person\knowledge\middleware\rabbitmq.png)

​																（图片来源[这里](https://www.jianshu.com/p/79ca08116d57)）

**Producer与Consumer**: 消息的发送方与消费方

**Exchange与Binding**:  Exchange与Binding是AMQP定义的比较独有的概念, Exchange直译是交换机的意思，在这里主要用来实现消息的规则路由，在使用时需要将Exchange和Queue进行配置绑定，绑定的结果就是Binding.  Exchange常见以下几种类型, 

**direct** 类型表示消息的RoutingKey与Binding配置的BindingKey完全匹配时，消息将转发至绑定的队列. 

**topic** 类型与direct有些类似，但支持模糊匹配, 定义的BindingKey用点号分隔的每一部分称为单词，*表示匹配一个单词, #表示多个或零个, 如配置绑定规则为\*.Rabbitmq.\*,  发送test.Rabbitmq.sms 将匹配成功

**fanout** 类型表示广播，Exchange的消息将直接路由给绑定Queue

**header** 类型由于性能较差，目前较小使用 

**Connection与Channel**:  Connection表示一个TCP网络连接， Channel 是建立在Connection之上的虚拟连接接可以节省资源实现多通道复用，一般一个线程对应的一个Channel，RabbitMq客户端的所有操作都是通过Channel来完成的。

**Virtual Host**:  支持多租户的概念，不同的Virtual Host里Exchange, Queue等资源是逻辑隔离的

#### 3.1.2 命令架构

AMQP定义了一系列命令来与Broker交互，来实现对上述模型的操作。命令大概分为以下几类

**Connection**:  连接建立/关闭，安全验证等

**Chananel**:  通道建立/关闭

**Exchange**:  通信声明/删除等

**Queue**:  队列声明/绑定/删除等

**Basic**:  消息发送/消费/结果返回等

**Transaction**: 事务支持

命令的内容格式可以想象跟我们常见命令行格式类似, 例如一个队列声明命令

```shell
Queue.Declare
	queue=my.queue
	auto-delete=TRUE
	exclusive=FALSE
```

可以对应一个API操作

```c
queue_declare (session, "my.queue", TRUE, FALSE);
```

#### 3.1.3 传输协议帧

最终一个命令发送到Broker是通过协议帧实现的， AMQP定义帧的格式如下:

![1607828316558](D:\person\knowledge\middleware\rabbitmq_frame.png)
定义有以下几种帧类型:

方法帧表示传输内容是命令以及相关的参数等，内容帧粗略就是消息传输的二进制内容，另外还有心跳帧和错误处理帧， 详细内容可参见协议文档。

#### 3.1.4 集群

在生产环境一般都是集群布署，Rabbitmq提供2种方式集群支持，一种是常规的局域网集群，另一种是支持广域网的Federation 和Shovel.

**局域网集群**: 基于性能和存储空间考量，在集群中创建的队列只会存在单个节点而不是所有节点存在。节点之间会同步所有元数据(交换器，绑定, Vhost，队列等元数据)，当客户端连接当前节点

官方文档有更详细的[比较](https://www.rabbitmq.com/distributed.html)

#### 3.1.5 其它

####  



#### 3.2. RocketMq

长轮询

#### 3.3. Kafka

#### 3.4. 技术选型

RabbitMq   轻量，迅捷，容易部署和使用，拥有灵活的路由配置

RocketMq  低延迟和金融级的稳定性

Kafka  性能

Kafka 海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品

#### 3.5. 其它

ActiveMQ, ZeroMQ 

Pulsar

### 4. 常见使用问题

#### 4.1  消息有序性

试想这样一种业务场景, 系统产生订单创建，订单更新，订单支付，扣减库存等多种消息，在业务语义上来说消费肯定需要保证其顺序性。  

首先，从生产者的角度需要保证消息发送的顺序，即前面的消息发送成功了，才能发送后面的消息，通过提供消息发送确认机制可以实现

在Broker端，需要保持队列的FIFO语义，一般配置好合理消费模型如点对点，问题不大

在消费端应该确保前面的消息消费成功再消费下一个消息，类似一个串行消费的效果。但在实际应用中，我们一般不需要保持全局有序(全局有序性能也差不好扩展)，就示例这个业务场景我们只要保证在订单级别的消费有序就可以了，消息队列发送消息时一般会额外支持一个Key参数，将Key作为参数使用哈希算法将相同的Key路由到相同队列,从而可以保证某一级别的消息严格有序。

#### 4.2  重复消息

从生产者到Broker，再从Broker到消费者，这中间至少发生了2次网络通讯，有网络通讯的场景很难保证消息不重复。

在MQTT消息协议对消息质量定义了三个等级：

**at most once**: 至多一次. 消息在传递过程中，最多被送达一次, 也就是说允许消息丢失，但不允许重复。

**at least once**: 至少一次.  消息在传递过程中，至少被送达一次,也就是不允许丢消息，但允许少量重复。

**exactly once**：恰好一次. 消息不允许丢失也不允许重复。

市面大部分消息中间件提供的服务质量是at least once。

即然重复消息从根本上来说难以避免，一般的解决办法就是在消费端做文章，让消费操作支持**幂等**性， 即多次消费和一次消费产生的影响相同。最佳的实践是从业务逻辑设计上考虑，将消费的业务逻辑设计具有幂等性，当然有些业务无法做到幂等，可以在技术层面引入一些方法来实现，如数据库唯一键，全局唯一id等，这个具体业务具体分析了。

#### 4.3 消息可靠传递

消息可靠传递指消息传递过程中不丢失消息，首先要有手段检测是否发生消息丢失，有条件资源的可引入分布式链路追踪系统，方便跟踪每一条消息轨迹。无条件资源可以利用消息产生的有序性，为每一条发出消息附加一个递增的序列号，然后在消费端检测序号的连续性，如果检测试到序号不连续，那就是丢消息了。一般客户端都有拦截器的机制，检测消息丢失检查可以放在拦截器中处理，不影响正常的业务逻辑代码。

确保消息可靠传递可以分成几个阶段来处理

**消费者生产**   生产者将消息创建并发生至Broker时，需要利用消息队列提供的发送确认机制，在代码中检查每一条消息的发送结果，做好异常处理，检测到错误可以记录日志，采取重试发送或消息补偿等技术手段。

**Broker接收存储**  Broker一般提供相应的配置参数，在接收消息并写入磁盘后再给生产端返回确认响应，如果对可靠性有非常高的要求，在集群环境为避免单点故障，可以配置至少写入2个节点才返回响应。

**消费者消费** 消费端也有和生产类似确认机制，从Broker拉取消息执行消费业务逻辑后，才给Broker发送消费确认

#### 4.4 分布式事务

消息队列一般者会支持事务消息来支持分布式事务实现数据最终一致性，但注意与我们熟悉数据库事务特性相比有很大不同。下面来看一个具体的业务场景，设想在一个订单系统中，订单创建后需要通信通知客户创建成功, 短信通知不属于核心业务逻辑，我们可以使用消息队列解耦，将创建成功的消息异步通知短信发送系统。在业务上来说，我们需要保证订单创建成功和通知短信**要不都成功或要不都失败**。下面看一下如何使用消息队列事务支持实现这个场景：

![1607571640549](D:\person\knowledge\middleware\middleware_transaction.png)

   1 . 调用Producer API开启消息事务模式

2.  发送"半"消息至Broker,  所谓半消息Broker只是将消息临时缓存，并不会马上投递给消费者

3.  执行本地事务业务逻辑，创建订单

4.  根据本地事务结果提交或回滚消息事务。

   敏感细心的同学可能会发现在第4步可能存在问题，如果第4步操作失败应该怎么办？大部分消息队列是将这个问题交给开发者自行处理，RocketMq有个特别的设计，提供了一个本地事务接口反查机制，定期反查本地事务提交结果来决定消息事务是提交或回滚事务消息。 

除了利用消息队列本身的事务特性支持，还可以使用类似本地消息表的更适应性方案来实现数据的最终一致性，深入了解可参见[Cap](https://github.com/dotnetcore/CAP/blob/master/README.zh-cn.md) 这个开源项目。

最后，你可以比较消息事务我们常见的数据库事务ACID特性有什么异同？

#### 4.5 性能与消息积压

在使用消息队列时我们要确保一个基本的原则，**消费端的性能要高于生产端的性能**, 这样才能保证系统健康运行。当消费端性能低于生产端的性能，就可能发生消息积压。在使用消息队列时我们一般不用考虑Broker的性能，因为Broker性能一般远大于业务系统的处理能力，单结点的Broker性能一般每秒至少可以处理几万乃至十几万的消息，而业务系统的TPS一般在几千级别。性能优先从生产端和消费端来考虑。

**生产端性能优化**  生产端发送消息一般是在业务逻辑执行之后，如果发现生产端性能低下，首先可能要检查自身的业务逻辑是不是存在问题，耗时太多。另外技术层面的优化是提高发送并发数，如果可以接受延迟可以改成批量发送，这样一般可以达到比较好的性能。

**消费端性能优化** 消费端的性能提升也是优先检查消费逻辑，另外一个思路可以扩容增加分区数量，一般分区数数量等于消费者数量。

**消息积压** 当发生消息积压时，大致问题可能出在2个方面，一方面可能是发送变快了，再一个可能是消费变慢了。可以通过消息队列的监控设施提供的数据定位问题。对于发送变快了导致积压，有的消息队列提供了流控机制，可以自动降低生产端的发送速度，另一个临时办法可以关闭一些非核心业务，在另一个层面降低消息发送量 。消费端变慢需要具体情况具体分析， 消费逻辑可能需要访问数据库，但由于流量变大超过数据库容量限制导致访问缓慢，也可能需要调用外部服务，但外部服务出现问题导致不可用或网络延迟导致消费变慢，另一个比较少的情况是存在消费处理逻辑不严谨，消费处理过程中出错导致消息不成功而反复消费。如果排除了消费慢的问题，另一个常用手段就是对消息队列进行扩容，增加消费者并发数量。

在使用消息队列前应该进行消息容量规划和压力测试, 确保系统在合理的负载范围。

### 5. 总结

本文从开发人员的角度，简单介绍了目前流行的消息队列基本特性和原理，并论述相关的队列的技术选型关注点，

并就使用过程中的一些通用问题进行了分析和介绍，但其它运维管理等其它方面由于篇幅和个人水平有限没有涉及。

### 6. 参考资料

**官网** 

https://www.rabbitmq.com/

http://rocketmq.apache.org/

http://kafka.apache.org/

**极客时间**

<消息队列高手课>

<Kafka核心技术与实战>

**书** 

<分布式消息中间件实践>

<深入理解Kafka：核心设计与实践原理>

<RabbitMQ实战指南>

<RocketMQ技术内幕>

**链接**

 [日志：每个软件工程师都应该知道的有关实时数据的统一概念](http://www.oschina.net/translate/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)

[AMQP高级消息队列协议](https://www.amqp.org/)