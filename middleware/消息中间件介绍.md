### 1. 前言

​			系统间通信可以分为直接与间接通信，直接通信大家在开发中接触很多，一般使用基于请求应答模型RPC技术，用于点对点，强事务要求和延迟敏感的通信场景。而间接通信主要使用消息中间件的方式实现，消息中间件本质是增加了一个中转中间层，实现消息的临时存储和路由转发。从而可以用在很多有意思的业务场景，如系统解藕, 流量削峰，异步通信, 日志收集等。消息中间件的选择可谓琳琅满目，有许多开源的和商业的实现，在特定的业务场景，你甚至可以借助Mysql或Redis轻松实现一个自已的消息队列。本文主要介绍开源的RabbitMq, RocketMq和Kafka产品特性，实现原理和技术选型。

### 2.  概述

消息中间件的基本模型如下

​             ![image-20201126230001320](D:\person\knowledge\middleware\middleware_base.png)

Producer: 负责产生和发送消息到消息处理中心 

Broker: 消息处理中心，负责消息的接收，存储，转发等

Consumer:  从消息处理中心获取消息进行处理

一条消息从发送到消费的过程，中间要经历不少节点，下面具体分析一下各个节点有关的技术。

#### 2.1 消息发送Producer到Broker

消息发送基于不同应用场景可以选择不同的发送方式, 包括同步，异步，批量或Fire and Forget等。

有时候还需要考虑事务消息, 另外消息本身有优先级，序列化与反序列化等。 

#### 2.2 消息接收Broker

Broker端考虑消息接收后，消息可以存储是在内存中或刷盘存储,

刷盘可以考虑同步或异步， 另外为了提搞消费查询效率，会同步生成索引文件。

 Broker端同时要存储消费的或集群元数据信息

#### 2.3 消息消费Broker到Consumer

消费一般要支持点对点和发布订阅模型，其它的一些特殊还包括广播，Topic过滤等。       

消息消费方式的选择可根据应用场景选择push或pull。

消费完成需要考虑消息确认， 在一些特殊场合要支持消息回溯或消息均衡等.

以上这些技术有些定义公开的协议并标准化，如AMQP, MQTT, XMPP等，更多消息队列的使用了私有协议。

不同的消息队列产品在一些点有不同的设计取舍考虑和创新，下面我们具体看RabbitMq, RocketMq和Kafka的各自特点。

### 3.  主流消息中间件

介绍常见消息队列的特点,工作原理

#### 3.1. RabbitMq

#### 3.2. RocketMq

长轮询

#### 3.3. Kafka

#### 3.4. 技术选型

RabbitMq   轻量，迅捷，容易部署和使用，拥有灵活的路由配置

RocketMq  低延迟和金融级的稳定性

Kafka  性能

Kafka 海量的消息，像收集日志、监控信息或是前端的埋点这类数据，或是你的应用场景大量使用了大数据、流计算相关的开源产品

#### 3.5. 其它

ActiveMQ, ZeroMQ 

Pulsar

### 4. 常见通用问题

#### 4.1  消息有序性

试想这样一种业务场景, 系统产生订单创建，订单更新，订单支付，扣减库存等多种消息，在业务语义上来说消费肯定需要保证其顺序性。  

首先，从生产者的角度需要保证消息发送的顺序，即前面的消息发送成功了，才能发送后面的消息，通过提供消息发送确认机制可以实现

在Broker端，需要保持队列的FIFO语义，一般配置好合理消费模型如点对点，问题不大

在消费端应该确保前面的消息消费成功再消费下一个消息，类似一个串行消费的效果。但在实际应用中，我们一般不需要保持全局有序(全局有序性能也差不好扩展)，就示例这个业务场景我们只要保证在订单级别的消费有序就可以了，消息队列发送消息时一般会额外支持一个Key参数，将Key作为参数使用哈希算法将相同的Key路由到相同队列,从而可以保证某一级别的消息严格有序。

#### 4.2  重复消息

从生产者到Broker，再从Broker到消费者，这中间至少发生了2次网络通讯，有网络通讯的场景很难保证消息不重复。

在MQTT消息协议对消息质量定义了三个等级：

**at most once**: 至多一次. 消息在传递过程中，最多被送达一次, 也就是说允许消息丢失，但不允许重复。

**at least once**: 至少一次.  消息在传递过程中，至少被送达一次,也就是不允许丢消息，但允许少量重复。

**exactly once**：恰好一次. 消息不允许丢失也不允许重复。

市面大部分消息中间件提供的服务质量是at least once。

即然重复消息从根本上来说难以避免，一般的解决办法就是在消费端做文章，让消费操作支持**幂等**性， 即多次消费和一次消费产生的影响相同。最佳的实践是从业务逻辑设计上考虑，将消费的业务逻辑设计具有幂等性，当然有些业务无法做到幂等，可以在技术层面引入一些方法来实现，如数据库唯一键，全局唯一id等，这个具体业务具体分析了。

#### 4.3 消息可靠传递

消息可靠传递指消息传递过程中不丢失消息，首先要有手段检测是否发生消息丢失，有条件资源的可引入分布式链路追踪系统，方便跟踪每一条消息轨迹。无条件资源可以利用消息产生的有序性，为每一条发出消息附加一个递增的序列号，然后在消费端检测序号的连续性，如果检测试到序号不连续，那就是丢消息了。一般客户端都有拦截器的机制，检测消息丢失检查可以放在拦截器中处理，不影响正常的业务逻辑代码。

确保消息可靠传递可以分成几个阶段来处理

**消费者生产**   生产者将消息创建并发生至Broker时，需要利用消息队列提供的发送确认机制，在代码中检查每一条消息的发送结果，做好异常处理，检测到错误可以记录日志，采取重试发送或消息补偿等技术手段。

**Broker接收存储**  Broker一般提供相应的配置参数，在接收消息并写入磁盘后再给生产端返回确认响应，如果对可靠性有非常高的要求，在集群环境为避免单点故障，可以配置至少写入2个节点才返回响应。

**消费者消费** 消费端也有和生产类似确认机制，从Broker拉取消息执行消费业务逻辑后，才给Broker发送消费确认

#### 4.4 分布式事务

消息队列一般者会提供事务消息来支持分布式事务，但注意与我们熟悉数据库事务特性相比相差甚远。下面来看一个具体的业务场景，设想在一个订单系统中，订单创建后需要通信通知客户创建成功, 短信通知不属于核心业务逻辑，我们可以使用消息队列，将成功的消息异步通知短信发送系统。在业务上来说，我们需要保证订单创建成功和通知短信不要**都不成功或要不都失败**。



事务消息补偿

消息事务表

消息事务符合我们常见的数据库事务ACID特性吗？

#### 4.5 流控与消息积压

#### 

### 5. 总结

### 6. 参考资料

**官网** 

https://www.rabbitmq.com/

http://rocketmq.apache.org/

http://kafka.apache.org/

**极客时间**

<消息队列高手课>

<Kafka核心技术与实战>

**书** 

<分布式消息中间件实践>

<深入理解Kafka：核心设计与实践原理>

<RabbitMQ实战指南>

<RocketMQ技术内幕>

**链接**

 [日志：每个软件工程师都应该知道的有关实时数据的统一概念](http://www.oschina.net/translate/log-what-every-software-engineer-should-know-about-real-time-datas-unifying)

[AMQP高级消息队列协议](https://www.amqp.org/)