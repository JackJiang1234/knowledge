### 什么是单元测试

在软件开发领域, 长期以来人们有一个朴素的愿望，希望通过类似搭积木的方式，将**组件**一层层组合起来完成开发工作。愿望很美好，但目前来看是革命尚未成功，同志们仍需努力。但另一层面也揭示了软件由各类组件组合而成，那怎么保证每个组件组合起来如预期那样工作呢？自然人们引入**测试**方法来验证组件是否按规定的契约来运行。如果把组件一直细分到不能再分最低级别的程序单元，针对这种单元的测试称之为单元测试，在现实世界通常对应到一个类的方法或函数。单元测试是由程序员来实施的白盒测试，其目的是在对集成测试和功能测试前对基本的程序单元逐一检查验证。关于测试的整体关系参考下面的**测试金字塔**。

![测试金字塔](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9tbWJpei5xcGljLmNuL21tYml6X3BuZy9mQ3BkMWNmOGlhY2FMcVVseWZTQ1JWTHdKQ2dhNUNCc1d0a0t1Q2FvV080ZkhWQVpLajluM1RLRGxxSlVKTEZQeEMzVGM0RFF2dmZpYUxIQWZuNkhQMHJ3LzY0MA?x-oss-process=image/format,png)

### 为什么要单元测试

很多同学认为实现了功能逻辑，再编写单元测试有点多余，增加了开发的工作量, 意义不大。单元测试有点类似价值投资，随着软件规模的扩大和演化，会产生越来越大的价值。

#### 驱动优秀设计

良好的设计接口清晰，抽象合理，符合基本的设计原则，编写测试会流畅自然，如果你发现测试编写困难，如陷泥团，也许这是对你当前设计坏味道的提醒。

#### 安全防护网

当为系统编写的单元测试越来越多, 系统的代码都有测试用例覆盖，单元测试就演变成一张安全防护网，保障大部分系统修改缺陷都能被快速发现和修复。软件工程实践证明，越早发现缺陷，其修复成本越低。 **测试驱动开发**更是提倡测试先行，使代码始终处于安全网防护之下。

#### 提高编码自信

单元测试总是能在你修改或重构代码即时反馈结果, 给予你调整的勇气，不用担心牵一发而动全身。帮助我们走向正反馈的道路，不断提高编码质量的同时增强心理自信。

### 怎么做单元测试

既然单元测试是验证类的方法或函数的行为是否如预期工作，基本思路当然是调用待测试的类方法再检查结果是否符合预期。针对某一个类方法编写的测试我们称之为**用例**，用例要满足**自动化，独立性，可重复**等原则， 用例之间不能互相调用，也不允许执行次序有先后依赖。要做到自动化，不能使用`Console.Write`之类打印结果来人工检查，而应该使用**断言**来自动验证结果。综合来说编写一个单元测试的基本步骤是:
1.准备测试环境与条件(分配对象与资源等); 
2.调用测试目标方法验证被测试方法行为与期望是否一致;
3.完成后清理资源;
想想编写测试用例时除了第2步，其它环境资源准备与管理每次重复编写是比较烦琐的，幸运的是早就先行者发明了各种各样的单元测试框架, 帮助我们更好的编写和组织测试用例。

#### 测试框架

.net 环境下比较知名的测试框架有xUnit, MsTest, NUnit等,  但设计和使用思路大同小异。以下主要介绍目前最流行的xUnit的基本特性(基于xUnit2.4.0版本)。

1. 集成

   xUnit支持.net core和.net Framework, 通过各种Runner和插件, 可以在命令行和Visual Studio等各种环境中运行

2. 基本用例标记[Fact]  

   Fact 标记方法为一个测试用例, 注意：xUnit 为每个测试用例都实例化一个对象，默认使用对象的构造函数和IDisposable接口作为环境资源准备和清理

   ```c#
   public class UnitTest 
       {
           private int count = 0;
   
           public UnitTest2()
           {
               this.count++;
           }
   
           [Fact]
           public void PassingTest1()
           {
               Assert.Equal(1, this.count);
           }
   
           [Fact]
           public void PassingTest2()
           {
               Assert.Equal(1, this.count);
           }
       }
   ```

3. 数据驱动测试 [Theory, InlineData, MemberData, ClassData, Data]

   有些场景下测试输入有多种组合，但测试逻辑是一致的，由此可以将条件组合抽取出来形成测试数据。 xUnit为数据输入测试提供了很多支持, Theory表示有一组数据输入组合的测试，InlineData表示输入一组数据与测试方法的每个参数按位置匹配， MemberData与ClassData分别表示数据来源是类的成员和指定的类，你甚至可以自定义实现DataAttribute实现自定数据来源提供。

   ```c#
   public class UnitTest1
   {
           [Theory]
           [InlineData(3, true)]
           [InlineData(5, true)]
           [InlineData(6, false)]
           public void MyFirstTheory(int value, bool result)
           {
               Assert.Equal(result, IsOdd(value));
           }
       
       	bool IsOdd(int value)
       	{
           	return value % 2 == 1;
       	}
   }
   ```

4. 用例组织[Collection, Trait]

   xUnit默认按测试所在的类来进行分组，同一个类中的测试用例作为一组用例顺序执行，使用Collection属性可以自定义将某些测试类用列编为一组.  使用Trait可以为用例打标签，方便在测试UI展示查看

   ```c#
   [Collection("group1")]
   [Trait("caseOrg", "test1")]
   public class UnitTest3
   {
        [Fact]
        public void MethodTest1()
        {
   	 }
   }
   
   [Collection("group1")]
   [Trait("caseOrg", "test2")]
   public class UnitTest4
   {
       [Fact]
       public void MethodTest1()
       {
       }
   
   }
   ```

5. 用例执行顺序指定[TestCaseOrderer与TestCollectionOrderer]

   一般情况下不推荐也没必要指定测试用例的执行顺序，xUnit提供了两个属性允许在测试类，集合与程序集级别自定义用例的执行顺序

   ```c#
   //第一个参数是自定义用例顺序实现类，第二个表示所在程序集
   [TestCaseOrderer("XUnitTestProject1.MyTestOrder", "XUnitTestProject1")]
   public class UnitTest2
   {
        [Fact]
        public void MethodTest1()
        {
        }
       
       [Fact]
       public void MethodTest2()
       {
       }
   }
   
   public class MyTestOrder : ITestCaseOrderer
   {
       public IEnumerable<TTestCase> OrderTestCases<TTestCase>(IEnumerable<TTestCase> testCases) 
           where TTestCase : ITestCase
       {
           return testCases.OrderByDescending(item => item.TestMethod.Method.Name);
       }
   }
   ```

6. 用例测试资源组织[IClassFixture与ICollectionFixture]

   有些场合可能需要在测试类与集合级别共享资源进行测试，xUnit分别提供IClassFixture和ICollectionFixture接口，测试类实现相应的接口，指定Fixture类型(注意Fixture要有无参构造函数)

   ```c#
   public class UnitTest4 : IClassFixture<ClassLevelFixture>
       {
           private readonly ClassLevelFixture classLevelFixture;
           public UnitTest4(ClassLevelFixture fixture)
           {
               this.classLevelFixture = fixture;
           }
       }
   
       public class ClassLevelFixture : IDisposable
       {
           public void Dispose()
           {
               throw new NotImplementedException();
           }
       }
   ```

7. 断言

   xUnit针对基本类型，对象，集合提供了丰富的断言(Assert), 相等性，异常，条件判断, 集合遍历，包含，筛选等。

#### 设计测试用例

前面提到单元测试是验证结果是否符合预期，根据不同的场景，验证可以通过直接或组合或交叉等多种方式来检查

```c#
public class UnitTest6
    {
        [Fact] //直接验证
        public void DirectResultTest()
        {
            var myArray = new int[] { 9, 8, 7, 6 };
            Array.Sort(myArray);
            for(int i = 0; i < myArray.Length - 1; i++)
            {
                Assert.True(myArray[i] < myArray[i+1]);
            }
        }
        
        [Fact] //反向算法实现, 交叉验证
        public void CrossTest()
        {
            double val = Math.Sqrt(4.0);
            Assert.Equal(4.0, val * val, 5);
        }
    }
```

更具体的来说，设计测试用例的基本方法是等价类划分和边界值分析，等价类划分是根据方法接口的设计，将所有可能的输入组合分门别类，每种情况作为一个测试用例。边界值分析是在等价类划分的基础上，选取边界值作为测试用列，长期工程实践证明，大部分程序的Bug就是出在对边界值的处理。

```c#

```

其它一些白盒的设计用例方法如
**语句覆盖**使用程序中每一条可执行语句至少被执行一次
**分支覆盖** 使程序中每一个分支都至少被执行一次
**条件覆盖**使程序中每一个条件至少有一次被满足
**路径覆盖**使程序中所有独立的基本路径至少要测试一次

有些场景被测方法依耐外部接口

#### 隔离框架



```

```



#### 测试覆盖率

最佳实践

#### 其它

Visual Studio集成IDE对单元测试提供了丰富特性支持，可以直接调试或运行测试，分析代码测试覆盖率，通过Test Explorer浏览所有测试运行情况，可以将测试加入Live Unit Test, 在编写完测试时，IDE自动运行测试，立刻得到结果反馈。



#### 



Mock, Fake, Stub 对象



### 做什么

设计:

面向测试的设计

测试驱动的设计



### 不能

UI， 多线程，

### 示例

### 意识与心理层面

 单元测试是道理人人都懂，但大部分人都没有坚持下去的典范,  许多同学走着走着忘了初心，为测试而测试，

自信的编码

不写测试的借口: 编写测试太耗费时间与精力， 测试运行时间， 测试并不是我的工作, 不知道怎么写,  如果让QA失业感觉很难过....

单元测试学习曲线

我们大部分是普通人，"慢就是快"

### 总结

本文介绍了单元测试的基本概念开发与测试本是一体，未测试代码不发布上线, 做时间的朋友。

1. 单元测试的定义和好处

2. 选择单元测试框架

3. 怎么给单元测试命名

4. 单元测试的组成

5. Stub（存根）和Mock（模拟对象）

6. 隔离框架

7. VisualStuio中的测试资源管理器、CodeLens和ReSharper

8. Live Unit Test

9. 代码覆盖率

10. 单元测试道_法_术

11. 单元测试熟练等级

12. 使用单元测试的最佳姿势

13. 通过实例说明单元测试

    

### 资料

[.Net Core单元测试覆盖率](https://docs.microsoft.com/zh-cn/visualstudio/test/unit-test-your-code?view=vs-2019)

[.Net Core单元测试最佳实践](https://docs.microsoft.com/zh-cn/dotnet/core/testing/unit-testing-best-practices)

[Xunit Site](https://xunit.net/)

[XUnit Patterns](http://xunitpatterns.com/index.html)

[测试用例的设计](https://zhuanlan.zhihu.com/p/62095921)

[测试用例示例](https://zhuanlan.zhihu.com/p/101211550)